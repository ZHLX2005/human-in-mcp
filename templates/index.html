<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ä»»åŠ¡é˜Ÿåˆ—ç®¡ç†</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f5f5;
            min-height: 100vh;
            padding: 20px;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
        }
        .panel {
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 12px rgba(0,0,0,0.08);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            max-height: calc(100vh - 40px);
        }
        .header {
            background: #ffffff;
            color: #333;
            padding: 16px 20px;
            text-align: center;
            border-bottom: 1px solid #e8e8e8;
            flex-shrink: 0;
        }
        .header h2 {
            font-size: 16px;
            font-weight: 600;
            color: #1a1a1a;
        }
        .header p {
            font-size: 11px;
            color: #999;
            margin-top: 4px;
        }
        .content {
            padding: 16px;
            overflow-y: auto;
            flex: 1;
        }
        .form-group { margin-bottom: 12px; }
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #333;
            font-size: 12px;
        }
        .form-group input, .form-group textarea, .form-group select {
            width: 100%;
            padding: 8px 10px;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            font-size: 12px;
            transition: all 0.2s;
            background: #fafafa;
        }
        .form-group input:focus, .form-group textarea:focus, .form-group select:focus {
            outline: none;
            border-color: #999;
            background: white;
        }
        .form-group textarea {
            min-height: 60px;
            resize: vertical;
        }
        .btn {
            width: 100%;
            padding: 8px 16px;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            background: white;
            color: #333;
            margin-bottom: 8px;
        }
        .btn:hover {
            background: #f5f5f5;
            border-color: #ccc;
        }
        .btn-primary {
            background: #333;
            color: white;
            border-color: #333;
        }
        .btn-primary:hover {
            background: #555;
            border-color: #555;
        }
        .list-header {
            font-size: 13px;
            margin-bottom: 10px;
            color: #333;
            font-weight: 600;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .badge {
            padding: 2px 8px;
            font-size: 10px;
            border-radius: 4px;
            background: #f0f0f0;
            color: #666;
        }
        .task-item, .render-item {
            background: #fafafa;
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 6px;
            border-left: 3px solid #999;
            font-size: 12px;
        }
        .task-item:hover, .render-item:hover {
            background: #f0f0f0;
        }
        .task-content, .render-item .summary {
            color: #333;
            margin-bottom: 4px;
            line-height: 1.4;
        }
        .task-meta, .render-meta {
            font-size: 10px;
            color: #888;
        }
        .render-item .options {
            margin-top: 8px;
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }
        .option-btn {
            padding: 3px 8px;
            font-size: 10px;
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .option-btn:hover {
            background: #333;
            color: white;
            border-color: #333;
        }
        .processed-item {
            background: #e8f5e9;
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 6px;
            border-left: 3px solid #4caf50;
            font-size: 12px;
            opacity: 0.9;
        }
        .processed-item .summary {
            color: #333;
            margin-bottom: 4px;
            line-height: 1.4;
        }
        .processed-item .response {
            color: #2e7d32;
            font-size: 11px;
            padding: 4px 8px;
            background: white;
            border-radius: 4px;
            margin-top: 4px;
        }
        .processed-item .timestamp {
            font-size: 9px;
            color: #888;
            margin-top: 4px;
        }
        .status-item {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 6px;
            border-left: 3px solid #6c757d;
            font-size: 12px;
        }
        .status-item.pending {
            border-left-color: #ffc107;
            background: #fff8e1;
        }
        .status-item.processing {
            border-left-color: #2196f3;
            background: #e3f2fd;
        }
        .status-item.completed {
            border-left-color: #4caf50;
            background: #e8f5e9;
        }
        .status-item .task-id {
            font-size: 9px;
            color: #888;
            margin-bottom: 4px;
        }
        .status-item .task-req {
            color: #333;
            margin-bottom: 4px;
            line-height: 1.4;
        }
        .status-item .task-resp {
            color: #2e7d32;
            font-size: 11px;
            padding: 4px 8px;
            background: white;
            border-radius: 4px;
            margin-top: 4px;
        }
        .status-badge {
            display: inline-block;
            padding: 2px 8px;
            font-size: 9px;
            border-radius: 4px;
            font-weight: 500;
            margin-bottom: 4px;
        }
        .status-badge.pending {
            background: #ffc107;
            color: #333;
        }
        .status-badge.processing {
            background: #2196f3;
            color: white;
        }
        .status-badge.completed {
            background: #4caf50;
            color: white;
        }
        .empty-state {
            text-align: center;
            padding: 30px 20px;
            color: #aaa;
            font-size: 12px;
        }
        .message {
            padding: 8px;
            border-radius: 6px;
            margin-bottom: 10px;
            display: none;
            font-size: 12px;
        }
        .message.success {
            background: #f0f5f0;
            color: #2d502d;
            border: 1px solid #c8e6c9;
        }
        .message.error {
            background: #fef0f0;
            color: #c62828;
            border: 1px solid #ffcdd2;
        }
        @media (max-width: 1200px) {
            .container { grid-template-columns: 1fr; }
            .panel { max-height: none; }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- å·¦ä¾§ï¼šæ‰‹åŠ¨æ·»åŠ ä»»åŠ¡ -->
        <div class="panel">
            <div class="header">
                <h2>ğŸ“ æ·»åŠ å¾…å¤„ç†ä»»åŠ¡</h2>
                <p>åˆ›å»ºæ–°çš„å¾…å¤„ç†ä»»åŠ¡</p>
            </div>
            <div class="content">
                <div id="manualMessage" class="message"></div>

                <form id="manualTaskForm">
                    <div class="form-group">
                        <label for="manualCustomInput">ä»»åŠ¡å†…å®¹</label>
                        <textarea id="manualCustomInput" placeholder="è¯·è¾“å…¥ä»»åŠ¡æè¿°..." required></textarea>
                    </div>

                    <div class="form-group">
                        <label for="formatInput">æ ¼å¼åŒ–æ¨¡æ¿</label>
                        <input type="text" id="formatInput" placeholder="%s" value="%s">
                        <div style="font-size: 10px; color: #999; margin-top: 4px;">ä½¿ç”¨ %s ä½œä¸ºå ä½ç¬¦ï¼Œä¾‹å¦‚ï¼šå‰ç¼€%såç¼€</div>
                    </div>

                    <div class="form-group">
                        <label for="manualContinueTask">ä»»åŠ¡ç±»å‹</label>
                        <select id="manualContinueTask">
                            <option value="true">ç»§ç»­ä»»åŠ¡</option>
                            <option value="false">ç»“æŸå¯¹è¯</option>
                        </select>
                    </div>

                    <button type="submit" class="btn btn-primary">æ·»åŠ ä»»åŠ¡</button>
                </form>

                <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid #e0e0e0;">
                    <div style="display: flex; gap: 8px; align-items: center; margin-bottom: 8px;">
                        <label style="font-weight: 500; color: #333; font-size: 12px;">å¯¼å…¥å†å²ä»»åŠ¡</label>
                    </div>
                    <input type="file" id="importFile" accept=".json" style="display: none;" onchange="handleFileSelect(event)">
                    <div id="dropZone"
                         style="border: 2px dashed #ccc; border-radius: 6px; padding: 20px; text-align: center; cursor: pointer; transition: all 0.2s; background: #fafafa;"
                         onclick="document.getElementById('importFile').click()"
                         ondragover="handleDragOver(event)"
                         ondragleave="handleDragLeave(event)"
                         ondrop="handleDrop(event)">
                        <div style="font-size: 24px; margin-bottom: 8px;">ğŸ“</div>
                        <div style="font-size: 12px; color: #666;">æ‹–æ”¾JSONæ–‡ä»¶åˆ°æ­¤å¤„</div>
                        <div style="font-size: 10px; color: #999; margin-top: 4px;">æˆ–ç‚¹å‡»é€‰æ‹©æ–‡ä»¶</div>
                    </div>
                    <div id="importTasksList" style="margin-top: 12px; display: none;">
                        <div style="font-size: 11px; color: #666; margin-bottom: 8px;">é€‰æ‹©è¦å¯¼å…¥çš„ä»»åŠ¡ï¼š</div>
                        <div id="importTasksItems" style="max-height: 200px; overflow-y: auto;"></div>
                        <button class="btn btn-primary" onclick="importSelectedTasks()" style="margin-top: 8px;">å¯¼å…¥é€‰ä¸­çš„ä»»åŠ¡</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- ä¸­é—´ï¼šAIæ¸²æŸ“ä»»åŠ¡ -->
        <div class="panel">
            <div class="header">
                <h2>ğŸ¤– AI æ¸²æŸ“ä»»åŠ¡</h2>
                <p>å¤„ç†AIå‘é€çš„äº¤äº’è¯·æ±‚</p>
            </div>
            <div class="content">
                <div id="renderMessage" class="message"></div>

                <div class="list-header">
                    <span>å¾…å¤„ç†ä»»åŠ¡</span>
                    <span id="renderCount" class="badge">0</span>
                </div>
                <div id="renderList">
                    <div class="empty-state">æš‚æ— AIä»»åŠ¡</div>
                </div>
            </div>
        </div>

        <!-- å³ä¾§ï¼šä»»åŠ¡çŠ¶æ€ -->
        <div class="panel">
            <div class="header">
                <h2>ğŸ“Š ä»»åŠ¡çŠ¶æ€</h2>
                <p>å®æ—¶è¿½è¸ªä»»åŠ¡è¿›åº¦</p>
            </div>
            <div class="content">
                <div class="list-header">
                    <span>å…¨éƒ¨ä»»åŠ¡</span>
                    <div style="display: flex; gap: 8px; align-items: center;">
                        <button class="btn" onclick="clearAllTasks()" style="padding: 4px 8px; font-size: 10px; margin-bottom: 0; background: #f44336; color: white; border-color: #f44336;">æ¸…ç©º</button>
                        <button class="btn" onclick="exportTasks()" style="padding: 4px 8px; font-size: 10px; margin-bottom: 0;">å¯¼å‡º</button>
                        <span id="statusCount" class="badge">0</span>
                    </div>
                </div>
                <div id="statusList">
                    <div class="empty-state">æš‚æ— ä»»åŠ¡çŠ¶æ€</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ç›‘å¬ä»»åŠ¡ç±»å‹å˜åŒ–
        document.getElementById('manualContinueTask').addEventListener('change', (e) => {
            const customInput = document.getElementById('manualCustomInput');
            if (e.target.value === 'false') {
                // ç»“æŸå¯¹è¯ï¼Œè‡ªåŠ¨å¡«å……æ–‡æœ¬å¹¶ç¦ç”¨è¾“å…¥æ¡†
                customInput.value = 'ç»“æŸä»»åŠ¡';
                customInput.disabled = true;
                customInput.required = false;
            } else {
                // ç»§ç»­ä»»åŠ¡ï¼Œå¯ç”¨è¾“å…¥æ¡†
                customInput.disabled = false;
                customInput.required = true;
                customInput.value = '';
            }
        });

        // æ ¼å¼åŒ–å­—ç¬¦ä¸²ç›¸å…³åŠŸèƒ½
        const formatInput = document.getElementById('formatInput');

        // åŠ è½½å½“å‰æ ¼å¼åŒ–å­—ç¬¦ä¸²
        async function loadFormat() {
            try {
                const response = await fetch('/api/format/get');
                const data = await response.json();
                formatInput.value = data.format;
            } catch (error) {
                console.error('åŠ è½½æ ¼å¼åŒ–å­—ç¬¦ä¸²å¤±è´¥:', error);
            }
        }

        // ä¿å­˜æ ¼å¼åŒ–å­—ç¬¦ä¸²
        async function saveFormat() {
            const newFormat = formatInput.value.trim();

            try {
                const response = await fetch('/api/format/set', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ format: newFormat })
                });

                if (response.ok) {
                    showMessage('manualMessage', 'æ ¼å¼åŒ–æ¨¡æ¿å·²æ›´æ–°', 'success');
                } else {
                    showMessage('manualMessage', 'æ›´æ–°å¤±è´¥', 'error');
                }
            } catch (error) {
                showMessage('manualMessage', 'ç½‘ç»œé”™è¯¯', 'error');
            }
        }

        // å½“æ ¼å¼åŒ–è¾“å…¥æ¡†å¤±å»ç„¦ç‚¹æ—¶è‡ªåŠ¨ä¿å­˜
        formatInput.addEventListener('blur', () => {
            if (formatInput.value.trim() !== '') {
                saveFormat();
            }
        });

        // é¡µé¢åŠ è½½æ—¶è·å–æ ¼å¼åŒ–å­—ç¬¦ä¸²
        loadFormat();

        // æ‰‹åŠ¨ä»»åŠ¡è¡¨å•
        document.getElementById('manualTaskForm').addEventListener('submit', async (e) => {
            e.preventDefault();

            const isContinue = document.getElementById('manualContinueTask').value === 'true';
            const task = {
                customInput: isContinue ? document.getElementById('manualCustomInput').value : 'ç»“æŸä»»åŠ¡',
                continue: isContinue
            };

            try {
                const response = await fetch('/api/tasks', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(task)
                });

                if (response.ok) {
                    showMessage('manualMessage', 'ä»»åŠ¡æ·»åŠ æˆåŠŸï¼', 'success');
                    document.getElementById('manualTaskForm').reset();
                    // é‡ç½®åé‡æ–°å¯ç”¨è¾“å…¥æ¡†
                    document.getElementById('manualCustomInput').disabled = false;
                    document.getElementById('manualCustomInput').required = true;
                    // é‡æ–°åŠ è½½æ ¼å¼åŒ–å­—ç¬¦ä¸²ï¼ˆé˜²æ­¢è¢«reseté‡ç½®ï¼‰
                    loadFormat();
                    loadTaskStatus();
                } else {
                    showMessage('manualMessage', 'æ·»åŠ å¤±è´¥ï¼š' + (await response.text()), 'error');
                }
            } catch (error) {
                showMessage('manualMessage', 'ç½‘ç»œé”™è¯¯ï¼š' + error.message, 'error');
            }
        });

        // åŠ è½½AIæ¸²æŸ“ä»»åŠ¡åˆ—è¡¨
        async function loadRenderTasks() {
            try {
                const response = await fetch('/api/render-tasks');
                const tasks = await response.json();

                const renderList = document.getElementById('renderList');
                document.getElementById('renderCount').textContent = tasks.length;

                if (tasks.length === 0) {
                    renderList.innerHTML = '<div class="empty-state">æš‚æ— AIä»»åŠ¡</div>';
                } else {
                    renderList.innerHTML = tasks.map((task, index) => {
                        let optionsHtml = '';
                        if (task.nextOptions && task.nextOptions.length > 0) {
                            optionsHtml = '<div class="options">';
                            task.nextOptions.forEach((opt, i) => {
                                optionsHtml += '<button class="option-btn" onclick="selectOption(' + i + ', \'' + escapeHtml(opt).replace(/'/g, "\\'") + '\')">[' + (i + 1) + '] ' + escapeHtml(opt.substring(0, 15)) + '</button>';
                            });
                            optionsHtml += '<button class="option-btn" onclick="showCustomInput()">è‡ªå®šä¹‰</button>';
                            optionsHtml += '<button class="option-btn" onclick="abandonTask()">é—å¼ƒ</button>';
                            optionsHtml += '<button class="option-btn" onclick="endChat()">ç»“æŸ</button>';
                            optionsHtml += '</div>';
                        }

                        return '<div class="render-item">' +
                            '<div class="summary">' + escapeHtml(task.summary) + '</div>' +
                            (task.difficulties && task.difficulties !== 'æ— ' ? '<div class="render-meta">âš ï¸ ' + escapeHtml(task.difficulties) + '</div>' : '') +
                            optionsHtml +
                            '</div>';
                    }).join('');
                }
            } catch (error) {
                console.error('åŠ è½½æ¸²æŸ“ä»»åŠ¡å¤±è´¥:', error);
            }
        }

        // åŠ è½½ä»»åŠ¡çŠ¶æ€
        async function loadTaskStatus() {
            try {
                const response = await fetch('/api/tasks/status');
                const tasks = await response.json();

                const statusList = document.getElementById('statusList');
                document.getElementById('statusCount').textContent = tasks.length;

                if (tasks.length === 0) {
                    statusList.innerHTML = '<div class="empty-state">æš‚æ— ä»»åŠ¡çŠ¶æ€</div>';
                } else {
                    statusList.innerHTML = tasks.map(task => {
                        let statusBadge = '';
                        switch(task.status) {
                            case 'pending':
                                statusBadge = '<span class="status-badge pending">ç­‰å¾…ä¸­</span>';
                                break;
                            case 'processing':
                                statusBadge = '<span class="status-badge processing">å¤„ç†ä¸­</span>';
                                break;
                            case 'completed':
                                statusBadge = '<span class="status-badge completed">å·²å®Œæˆ</span>';
                                break;
                            default:
                                statusBadge = '<span class="status-badge">' + task.status + '</span>';
                        }

                        let respHtml = '';
                        if (task.resp && task.resp !== '') {
                            respHtml = '<div class="task-resp">â†³ ' + escapeHtml(task.resp) + '</div>';
                        }

                        // ä¸ºpendingçŠ¶æ€çš„ä»»åŠ¡æ·»åŠ åˆ é™¤æŒ‰é’®
                        let deleteBtn = '';
                        if (task.status === 'pending') {
                            deleteBtn = '<button class="option-btn" onclick="deleteTask(\'' + escapeHtml(task.taskId) + '\')" style="margin-top: 4px; background: #f44336; color: white; border-color: #f44336;">åˆ é™¤</button>';
                        }

                        return '<div class="status-item ' + task.status + '">' +
                            '<div class="task-id">ID: ' + escapeHtml(task.taskId) + '</div>' +
                            statusBadge +
                            '<div class="task-req">' + escapeHtml(task.req) + '</div>' +
                            respHtml +
                            deleteBtn +
                            '</div>';
                    }).join('');
                }
            } catch (error) {
                console.error('åŠ è½½ä»»åŠ¡çŠ¶æ€å¤±è´¥:', error);
            }
        }

        // é€‰æ‹©AIé€‰é¡¹
        async function selectOption(index, optionText) {
            const task = {
                selectedIndex: index,
                continue: true,
                customInput: ''
            };

            try {
                const response = await fetch('/api/render-tasks/select', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(task)
                });

                if (response.ok) {
                    showMessage('renderMessage', 'å·²é€‰æ‹©: ' + optionText, 'success');
                    loadRenderTasks();
                    loadTaskStatus();
                } else {
                    showMessage('renderMessage', 'é€‰æ‹©å¤±è´¥', 'error');
                }
            } catch (error) {
                showMessage('renderMessage', 'ç½‘ç»œé”™è¯¯', 'error');
            }
        }

        // è‡ªå®šä¹‰è¾“å…¥
        function showCustomInput() {
            const customInput = prompt('è¯·è¾“å…¥æ‚¨çš„æŒ‡ç¤º:');
            if (customInput === null || customInput.trim() === '') return;

            const task = {
                selectedIndex: -1,
                continue: true,
                customInput: customInput
            };

            fetch('/api/render-tasks/select', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(task)
            }).then(response => {
                if (response.ok) {
                    showMessage('renderMessage', 'å·²æäº¤', 'success');
                    loadRenderTasks();
                    loadTaskStatus();
                }
            });
        }

        // ç»“æŸå¯¹è¯
        async function endChat() {
            const task = {
                continue: false,
                customInput: 'ç»“æŸå¯¹è¯'
            };

            try {
                const response = await fetch('/api/render-tasks/select', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(task)
                });

                if (response.ok) {
                    showMessage('renderMessage', 'å·²ç»“æŸå¯¹è¯', 'success');
                    loadRenderTasks();
                    loadTaskStatus();
                }
            } catch (error) {
                showMessage('renderMessage', 'æ“ä½œå¤±è´¥', 'error');
            }
        }

        // é—å¼ƒä»»åŠ¡ï¼ˆä¸éœ€è¦ç¡®è®¤ï¼‰
        async function abandonTask() {
            try {
                const response = await fetch('/api/render-tasks/abandon', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });

                if (response.ok) {
                    showMessage('renderMessage', 'ä»»åŠ¡å·²é—å¼ƒ', 'success');
                    loadRenderTasks();
                    loadTaskStatus();
                } else {
                    showMessage('renderMessage', 'é—å¼ƒå¤±è´¥', 'error');
                }
            } catch (error) {
                showMessage('renderMessage', 'ç½‘ç»œé”™è¯¯', 'error');
            }
        }

        // åˆ é™¤ä»»åŠ¡
        async function deleteTask(taskId) {
            if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªä»»åŠ¡å—ï¼Ÿ')) {
                return;
            }

            try {
                const response = await fetch('/api/tasks/delete', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ taskId: taskId })
                });

                if (response.ok) {
                    loadTaskStatus();
                } else {
                    alert('åˆ é™¤å¤±è´¥');
                }
            } catch (error) {
                alert('ç½‘ç»œé”™è¯¯');
            }
        }

        // å¯¼å‡ºæ‰€æœ‰ä»»åŠ¡ï¼ˆJSONæ ¼å¼ï¼‰
        async function exportTasks() {
            try {
                const response = await fetch('/api/tasks/status');
                const tasks = await response.json();

                if (tasks.length === 0) {
                    alert('æš‚æ— ä»»åŠ¡å¯å¯¼å‡º');
                    return;
                }

                // æ„å»ºå¯¼å‡ºæ•°æ®ç»“æ„
                const exportData = {
                    exportTime: new Date().toISOString(),
                    exportDate: new Date().toLocaleString(),
                    totalTasks: tasks.length,
                    tasks: tasks.map(task => ({
                        taskId: task.taskId,
                        status: task.status,
                        req: task.req,
                        resp: task.resp || '',
                        timestamp: new Date().toISOString()
                    }))
                };

                // è½¬æ¢ä¸ºJSONå­—ç¬¦ä¸²
                const jsonStr = JSON.stringify(exportData, null, 2);

                // åˆ›å»ºå¹¶ä¸‹è½½æ–‡ä»¶
                const blob = new Blob([jsonStr], { type: 'application/json;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'tasks_' + new Date().toISOString().slice(0, 10) + '.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            } catch (error) {
                alert('å¯¼å‡ºå¤±è´¥');
            }
        }

        // æ¸…ç©ºæ‰€æœ‰ä»»åŠ¡
        async function clearAllTasks() {
            if (!confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰ä»»åŠ¡å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ï¼')) {
                return;
            }

            try {
                const response = await fetch('/api/tasks/clear', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });

                if (response.ok) {
                    const result = await response.json();
                    alert(result.message || 'ä»»åŠ¡å·²æ¸…ç©º');
                    loadTaskStatus();
                } else {
                    alert('æ¸…ç©ºå¤±è´¥');
                }
            } catch (error) {
                alert('ç½‘ç»œé”™è¯¯');
            }
        }

        // æ‹–æ‹½ç›¸å…³äº‹ä»¶å¤„ç†
        function handleDragOver(event) {
            event.preventDefault();
            event.stopPropagation();
            const dropZone = document.getElementById('dropZone');
            dropZone.style.borderColor = '#2196f3';
            dropZone.style.background = '#e3f2fd';
        }

        function handleDragLeave(event) {
            event.preventDefault();
            event.stopPropagation();
            const dropZone = document.getElementById('dropZone');
            dropZone.style.borderColor = '#ccc';
            dropZone.style.background = '#fafafa';
        }

        function handleDrop(event) {
            event.preventDefault();
            event.stopPropagation();
            const dropZone = document.getElementById('dropZone');
            dropZone.style.borderColor = '#ccc';
            dropZone.style.background = '#fafafa';

            const files = event.dataTransfer.files;
            if (files.length > 0) {
                const file = files[0];
                if (file.name.endsWith('.json')) {
                    processImportFile(file);
                } else {
                    alert('è¯·é€‰æ‹©JSONæ–‡ä»¶');
                }
            }
        }

        // å­˜å‚¨å¯¼å…¥çš„ä»»åŠ¡æ•°æ®
        let importedTasks = [];

        // å¤„ç†å¯¼å…¥æ–‡ä»¶ï¼ˆç»Ÿä¸€å¤„ç†å‡½æ•°ï¼‰
        function processImportFile(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    if (data.tasks && Array.isArray(data.tasks)) {
                        importedTasks = data.tasks;
                        displayImportTasks(importedTasks);
                    } else {
                        alert('JSONæ–‡ä»¶æ ¼å¼ä¸æ­£ç¡®');
                    }
                } catch (error) {
                    alert('è§£æJSONæ–‡ä»¶å¤±è´¥: ' + error.message);
                }
            };
            reader.readAsText(file);
        }

        // å¤„ç†æ–‡ä»¶é€‰æ‹©
        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;
            processImportFile(file);
        }

        // å…¨é€‰/å–æ¶ˆå…¨é€‰å¯¼å…¥ä»»åŠ¡
        function toggleSelectAll(selectAll) {
            const checkboxes = document.querySelectorAll('#importTasksItems input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                checkbox.checked = selectAll;
            });
        }

        // æ˜¾ç¤ºå¯¼å…¥çš„ä»»åŠ¡åˆ—è¡¨
        function displayImportTasks(tasks) {
            const container = document.getElementById('importTasksList');
            const itemsContainer = document.getElementById('importTasksItems');

            if (tasks.length === 0) {
                alert('æ–‡ä»¶ä¸­æ²¡æœ‰ä»»åŠ¡');
                return;
            }

            // æ·»åŠ å…¨é€‰/å–æ¶ˆå…¨é€‰æŒ‰é’®
            let selectButtonsHtml = '<div style="display: flex; gap: 8px; margin-bottom: 8px;">' +
                '<button class="option-btn" onclick="toggleSelectAll(true)" style="flex: 1;">å…¨é€‰</button>' +
                '<button class="option-btn" onclick="toggleSelectAll(false)" style="flex: 1;">å–æ¶ˆå…¨é€‰</button>' +
                '</div>';

            itemsContainer.innerHTML = selectButtonsHtml + tasks.map((task, index) => {
                const escapedReq = escapeHtml(task.req);
                const preview = escapedReq.length > 50 ? escapedReq.substring(0, 50) + '...' : escapedReq;
                return '<div style="margin-bottom: 8px; padding: 8px; background: #f5f5f5; border-radius: 4px; border-left: 3px solid #999;">' +
                    '<div style="display: flex; align-items: start; gap: 8px;">' +
                    '<input type="checkbox" id="import_task_' + index + '" value="' + index + '" style="margin-top: 2px;">' +
                    '<label for="import_task_' + index + '" style="flex: 1; cursor: pointer;">' +
                    '<div style="font-size: 11px; color: #888; margin-bottom: 2px;">' + escapeHtml(task.taskId) + ' | ' + task.status + '</div>' +
                    '<div style="font-size: 12px; color: #333;">' + preview + '</div>' +
                    '</label>' +
                    '</div>' +
                    '</div>';
            }).join('');

            container.style.display = 'block';
        }

        // å¯¼å…¥é€‰ä¸­çš„ä»»åŠ¡
        async function importSelectedTasks() {
            const checkboxes = document.querySelectorAll('#importTasksItems input[type="checkbox"]:checked');

            if (checkboxes.length === 0) {
                alert('è¯·é€‰æ‹©è¦å¯¼å…¥çš„ä»»åŠ¡');
                return;
            }

            let successCount = 0;
            for (const checkbox of checkboxes) {
                const taskIndex = parseInt(checkbox.value);
                const task = importedTasks[taskIndex];

                try {
                    const response = await fetch('/api/tasks', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            customInput: task.req,
                            continue: true
                        })
                    });

                    if (response.ok) {
                        successCount++;
                    }
                } catch (error) {
                    console.error('å¯¼å…¥ä»»åŠ¡å¤±è´¥:', error);
                }
            }

            alert('æˆåŠŸå¯¼å…¥ ' + successCount + ' ä¸ªä»»åŠ¡');

            // æ¸…ç†
            document.getElementById('importFile').value = '';
            document.getElementById('importTasksList').style.display = 'none';
            importedTasks = [];
            loadTaskStatus();
        }

        function showMessage(elementId, text, type) {
            const message = document.getElementById(elementId);
            message.textContent = text;
            message.className = 'message ' + type;
            message.style.display = 'block';
            setTimeout(() => { message.style.display = 'none'; }, 2000);
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // é¡µé¢åŠ è½½æ—¶è·å–æ•°æ®
        loadRenderTasks();
        loadTaskStatus();
        // æ¯2ç§’è‡ªåŠ¨åˆ·æ–°
        setInterval(() => {
            loadRenderTasks();
            loadTaskStatus();
        }, 2000);
    </script>
</body>
</html>
